MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "April 27, 2017" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "12:33:52" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                April 27, 2017
Time:                12:33:52
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2B8QTD_ "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2B8QTD_ new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "April 27, 2017" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "12:33:52" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                Gaurav";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70125477";
MPRINT(EM_DIAGRAM):   put "Platform:            X64_8HOME";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M3P062415";
MPRINT(EM_DIAGRAM):   put "EM Version:          14.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "April 27, 2017" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "12:33:52" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                Gaurav";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
33971      proc freq data=EMWS1.TextParsing_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.TextParsing_VariableSet noprint;
33972      table ROLE*LEVEL/out=WORK.TextParsingMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.TextParsingMETA;
33973      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 1 observations read from the data set EMWS1.TEXTPARSING_VARIABLESET.
NOTE: The data set WORK.TEXTPARSINGMETA has 1 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.12 seconds
      cpu time            0.01 seconds
      

33974      proc print data=WORK.TextParsingMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.TextParsingMETA label noobs;
33975      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
33976      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency Count";
33977      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
33978      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
33979      run;

NOTE: There were 1 observations read from the data set WORK.TEXTPARSINGMETA.
NOTE: The PROCEDURE PRINT printed page 7.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

33980      title10;
MPRINT(EM_DIAGRAM):   title10;
33981      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextParsing: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextParsing: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'Insurance Claim';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Insurance Claim';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS1.Ids_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34323      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
34324      * TextParsing: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * TextParsing: Generation of macros and macro variables;
34325      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
34326      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

34327      %let EMEXCEPTIONSTRING=;
34328      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
34329      * TRAIN: TextParsing;
MPRINT(EM_DIAGRAM):   * TRAIN: TextParsing;
34330      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34331      %let EM_ACTION = TRAIN;
34332      %let syscc = 0;
34333      %macro main();
34334        %if %upcase(&EM_ACTION) eq CREATE %then %do;
34335          filename temp catalog 'sashelp.emtxtext.parse_create.source';
34336          %include temp;
34337          %create();
34338        %end;
34339        %if %upcase(&EM_ACTION) eq TRAIN %then %do;
34340          filename temp catalog 'sashelp.emtxtext.parse_train.source';
34341          %include temp;
34342          %train();
34343        %end;
34344        %if %upcase(&EM_ACTION) eq REPORT %then %do;
34345          filename temp catalog 'sashelp.emtxtext.parse_report.source';
34346          %include temp;
34347          %report();
34348        %end;
34349        %if %upcase(&EM_ACTION) eq SCORE %then %do;
34350          filename temp catalog 'sashelp.emtxtext.parse_score.source';
34351          %include temp;
34352          %score();
34353        %end;
34354          %if %upcase(&EM_ACTION) eq OPENTABLE1 %then %do;
34355             filename temp catalog 'sashelp.emtxtext.parse_actions.source';
34356             %include temp;
34357             filename temp;
34358             %openTable1;
34359         %end;
34360      %mend main;
34361      
34362      %main();
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.parse_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.PARSE_TRAIN.SOURCE.
34363     +%macro train();
34364     +   %global EM_SASMSG;
34365     +   %global sysdocparse;
34366     +   %global syshptmine;
34367     +   %global default_entity;
34368     +   %let EM_SASMSG=TMINE;
34369     +   %let sysdocparse = ;
34370     +   %let syshptmine = ;
34371     +   %let last_parse_node= ;
34373     +   /* Make sure there are no prior text parsing nodes in diagram */
34374     +   %if %sysfunc(exist(&EM_IMPORT_DATA_EMINFO)) %then %do;
34375     +      proc sql noprint;
34376     +      select data into :last_parse_node from &EM_IMPORT_DATA_EMINFO
34377     +         where key="LastTextParsing";
34378     +      quit;
34379     +      %if &last_parse_node ne %then %do;
34380     +         %let EMEXCEPTIONSTRING = EMTOOL.PRIORPARSINGNODE;
34381     +         %goto end_parse_train;
34382     +         %end;
34384     +      %end;
34387     +   /* make sure datasets are inited*/
34388     +    filename temp catalog 'sashelp.emtxtext.parse_actions.source';
34389     +    %include temp;
34390     +    %openTable1();
34392     +   /* check language setinit at runtime */
34393     +   filename temp catalog "sashelp.emtxtext.getlanguages.source";
34394     +   %include temp;
34395     +   %let found_language = ;
34396     +   proc sql noprint;
34397     +      select language into :found_language
34398     +      from work.tm_languages
34399     +      where upcase("&EM_PROPERTY_LANGUAGE") eq upcase(language);
34400     +   quit;
34401     +   %if &found_language eq %then %do;
34402     +      * error if language setinit expired ;
34403     +      /* %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE; */
34404     +      %let EMEXCEPTIONSTRING = EMTOOL.NOLANGLICENSE, %upcase(&EM_PROPERTY_LANGUAGE);
34405     +      %goto end_parse_train;
34406     +   %end;
34408     +   /* There must be a training or raw data set passed in */
34409     +    %if &em_import_data= %then %do;
34410     +      %let EMEXCEPTIONSTRING = EMTOOL.NOTRAINDS;
34411     +      %goto end_parse_train;
34412     +   %end;
34415     +   /* load tgparse macro */
34416     +   filename temp catalog "sashelp.emtxtext.tm_parse.source";
34417     +   %include temp;
34419     +   /* load multiword write to xml macro */
34420     +   filename temp catalog "sashelp.emtxtext.tmwritemulti.source";
34421     +   %include temp;
34423     +   /* retrieve the output datasets so we can write to them */
34424     +   %em_getname(key=terms, type=data);
34425     +   %em_getname(key=tmout, type=data);
34426     +   %em_getname(key=tmoutpos, type=data);
34427     +   %em_getname(key=tmconfig, type=data);
34428     +   %em_getname(key=synonymDS, type=data);
34429     +   %em_getname(key=multiDS, type=data);
34430     +   %em_getname(key=stopList, type=data);
34431     +   %em_getname(key=startList, type=data);
34433     +   %em_getname(key=multiword, type=file, extension=txt);
34435     +   /* variables for choosing the parsing column */
34436     +   %let tm_parsevar = ;
34437     +   %let tm_urivar = ;
34438     +   %let tm_filteredvar = ;
34439     +   %let tm_displayVar = ;
34441     +   /* crawl through the metadata to set some property defaults */
34442     +   data _null_;
34443     +      length parsevar urivar filteredvar $32;
34444     +      retain max_len 0;
34445     +      retain parsevar '';
34446     +      retain urivar '';
34447     +      retain filteredvar '';
34449     +      set &em_data_variableset end=eof;
34451     +      if upcase(ROLE)='TEXT' and USE in ('Y', 'D') and length > max_len then do;
34452     +         parsevar = name;
34453     +         max_len = length;
34454     +      end;
34455     +      if upcase(ROLE)='TEXTLOC' and USE in ('D', 'Y') then filteredvar = name;
34456     +      if ROLE='URIVAR' and USE in ('D', 'Y') then urivar = name;
34458     +      if eof then do;
34459     +         call symput('tm_parsevar', parsevar);
34460     +         call symput('tm_urivar', urivar);
34461     +         call symput('tm_filteredvar', filteredvar);
34462     +      end;
34463     +   run;
34466     +   %if %trim(%left(&tm_filteredvar)) ne %then %do;
34467     +      %let tm_displayVar = &tm_parseVar;
34468     +      %let tm_parsevar = &tm_filteredvar;
34469     +   %end;
34471     +   %em_propertychange(NAME=parseVar, VALUE=&tm_parsevar);
34473     +   %if %trim(%left(&tm_parsevar)) eq %then %do;
34474     +      /* error if no parsevar is found */
34475     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSEVAR;
34476     +      %goto end_parse_train;
34477     +   %end;
34478     +   %else %do;
34479     +      /* identify which variable we are parsing */
34480     +      %put &em_codebar;
34481     +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.PARSEVAR_NOTE, NOQUOTE, &tm_parsevar));
34482     +      %put &errormsg;
34483     +      %put &em_codebar;
34484     +   %end;
34486     +   /* *** synonym data set changes *** */
34487     +   /* modify the synonymDS to a format that docparse can take (term, termrole, parent, parentrole) */
34488     +   %let category_exists = 0;
34489     +   %let termrole_exists = 0;
34490     +   %let parentrole_exists = 0;
34491     +   %let synonym_warning = ;
34492     +   data _null_;
34493     +      dsid=open("&EM_USER_SYNONYMDS");
34494     +      check=varnum(dsid,'category');
34495     +      if check ne 0 then call symput('category_exists', '1');
34496     +      check=varnum(dsid,'termrole');
34497     +      if check ne 0 then call symput('termrole_exists', '1');
34498     +      check=varnum(dsid,'parentrole');
34499     +      if check ne 0 then call symput('parentrole_exists', '1');
34500     +   run;
34502     +   proc sql noprint;
34503     +      create table work.internal_synds as
34504     +         select term, parent,
34505     +            %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then %do;
34506     +            /* termrole exists and parentrole exists, so just use them */
34507     +               termrole, parentrole
34508     +            %end;
34509     +            %else %if &termrole_exists ne 0 and &parentrole_exists eq 0 %then %do;
34510     +            /* no parentrole or category, so create a termrole as parentrole */
34511     +               %let synonym_warning = 1 ;
34512     +               termrole,
34513     +               termrole as parentrole
34514     +            %end;
34515     +            %else %if &termrole_exists eq 0 and &parentrole_exists ne 0 %then %do;
34516     +            /* no termrole or category, so create a parentrole as termrole*/
34517     +               %let synonym_warning = 1 ;
34518     +               parentrole as termrole,
34519     +               parentrole
34520     +            %end;
34521     +            %else %if &termrole_exists eq 0 and &parentrole_exists eq 0 and &category_exists eq 0 %then %do;
34522     +             /* no termrole, parentrole, and category, so create a blank termrole and a blank parentrole*/
34523     +               "" as termrole,
34524     +               "" as parentrole
34525     +            %end;
34526     +            %else %if &category_exists ne 0 %then %do;
34527     +            /* we're missing both termrole or parentrole, but we have category, so just use that for termrole and parentrole */
34528     +               category as termrole,
34529     +               category as parentrole
34530     +            %end;
34531     +         from &EM_USER_SYNONYMDS;
34532     +   quit;
34534     +   /* reset parentrole_exists and termrole_exists */
34535     +   %let parentrole_exists = 1;
34536     +   %let termrole_exists = 1;
34539     +    %let entities='PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE',
34540     +                 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS',
34541     +                 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD';
34543     +    data work.internal_synds;
34544     +        set work.internal_synds;
34545     +        %if &termrole_exists %then %do;
34546     +            if KUPCASE(termrole) in (&entities ) then
34547     +                termrole=KUPCASE(termrole);
34548     +        %end;
34549     +        %if &parentrole_exists %then %do;
34550     +            if KUPCASE(parentrole) in (&entities) then
34551     +                parentrole=KUPCASE(parentrole);
34552     +        %end;
34553     +    run;
34555     +   %let EM_USER_SYNONYMDS = work.internal_synds;
34556     +   %if &synonym_warning ne %then %do;
34557     +      %put &em_codebar;
34558     +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.SYN_CHANGE_WARN, NOQUOTE));
34559     +      %put &errormsg;
34560     +      %put &em_codebar;
34561     +   %end;
34563     +   /* Remove duplicate keys from input tables */
34564     +    proc sort data=work.internal_synds nodupkey;
34565     +        by term parent %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then termrole parentrole;
34566     +        %else category; ;
34567     +    run;
34569     +   proc sql noprint;
34570     +       select count(*) into :stoplist_count
34571     +       from &em_user_stoplist;
34572     +       select count(*) into :startlist_count
34573     +       from &em_user_startlist;
34574     +       create view _trainview as select * from &em_import_data;
34575     +    quit;
34577     +    %if &stoplist_count ne 0 %then %do;
34578     +        %let role_exists = 0;
34579     +        data _null_;
34580     +          dsid=open("&em_user_stoplist");
34581     +          check=varnum(dsid,'role');
34582     +          if check ne 0 then call symput('role_exists', '1');
34583     +        run;
34584     +        proc sort data=&em_user_stoplist nodupkey;
34585     +            by term %if &role_exists ne 0 %then role;;
34586     +        run;
34587     +    %end;
34588     +    %else %if &startlist_count ne 0 %then %do;
34589     +        proc sort data=&em_user_startlist nodupkey;
34590     +            by term role;
34591     +        run;
34592     +    %end;
34596     +    /* Filter out unwanted languages */
34597     +    %let filt=;
34598     +    %if %symexist(EM_PROPERTY_FILTERLANG) %then %if &EM_PROPERTY_FILTERLANG ne %then %do;
34599     +        %let filt=%qkupcase(&EM_PROPERTY_FILTERLANG);
34600     +        %let filt=%qsysfunc(KTRANSLATE(%qktrim(&filt),", "," "));
34601     +        %let filt= %superq(filt);
34602     +        %let filt=%qsysfunc(TRANSTRN(&filt, %str(%')%qkupcase(%sysfunc(sasmsg(sashelp.tmine, rpt_text_blank_value, NOQUOTE)))%str(%'), ''));
34603     +        /* need to account for both Chinese languages */
34604     +        %let chineseStr = %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zho_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zht_value,
34605     + NOQUOTE))));
34606     +        %let filt=%qsysfunc(TRANSTRN(&filt, %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))), &chineseStr));
34608     +        filename temp catalog 'sashelp.emtxtext.tm_filter_languages.source';
34609     +        %include temp;
34611     +        %tm_filter_languages(indata=&EM_IMPORT_DATA, outdata=_trainview, languages=%nrbquote(&filt), report_role=TRAIN);
34613     +        proc sql noprint;
34614     +            select count(*) into :doccnt from _trainview;
34615     +        quit;
34617     +        %if &doccnt = 0 %then %do;
34618     +            %let emexceptionstring=EMTOOL.FILTER_DATA_ZERO;
34619     +            %goto end_parse_train;
34620     +        %end;
34621     +    %end;
34623     +    /* prepare training dataset for processing */
34624     +    data &EM_EXPORT_TRAIN.(compress=yes);
34625     +        set _trainview;
34627     +        _document_ = _n_;
34628     +        label _document_="%sysfunc(sasmsg(sashelp.tmine, rpt_text_document_vlabel, NOQUOTE))";
34629     +    run;
34631     +   /* set metadata on &EM_EXPORT_TRAIN to give _document_ a role of id and
34632     +      measurement level of nominal
34633     +    */
34634     +   %em_metachange(name=_document_, role=ID, level=NOMINAL);
34636     +   /* Write the multiword XML out */
34637     +   %tmwritemulti(multids=&EM_USER_MULTIDS,
34638     +                 stopds=&EM_USER_STOPLIST,
34639     +                 startds=&EM_USER_STARTLIST,
34640     +                 synds=&EM_USER_SYNONYMDS,
34641     +                 multi=&EM_USER_MULTIWORD,
34642     +                 multidsout= &EM_LIB..&EM_NODEID._multiall);
34643     +%let default_entity=;
34644     +   /* The main parsing call for the docs */
34645     +   %tm_parse(inds=&EM_EXPORT_TRAIN,
34646     +             outds=&em_user_tmout,
34647     +             keyds=&EM_USER_TERMS,
34648     +             config=&EM_USER_TMCONFIG,
34649     +             multisyn=&EM_USER_MULTIWORD,
34650     +             var=&TM_PARSEVAR,
34651     +             stemming=&EM_PROPERTY_BSTEMS,
34652     +             filevar=&tm_filteredvar,
34653     +             stoplist=&EM_USER_stopList,
34654     +             startlist=&EM_USER_startList,
34655     +             delimit=&EM_PROPERTY_DELIMIT,
34656     +             tagging=&EM_PROPERTY_BPARTOFSPEECH,
34657     +             language=&EM_PROPERTY_LANGUAGE,
34658     +             ng=&EM_PROPERTY_NOUNGROUPS,
34659     +             TGConcepts=%superq(EM_PROPERTY_TGConcepts),
34660     +             TGCategories=&EM_PROPERTY_TGCategories,
34661     +             indexDir=&EM_NODEDIR.&EM_DSEP.,
34662     +             entities=&EM_PROPERTY_BPATTERNS,
34663     +             posignore=&EM_PROPERTY_IGNOREPOS,
34664     +             entignore=&EM_PROPERTY_IGNOREENTITIES,
34665     +             attribignore=&EM_PROPERTY_IGNOREATTRIB,
34666     +             filterds=,
34667     +             filterstatus=,
34668     +             synDS=&EM_USER_SYNONYMDS,
34669     +             outpos=&EM_USER_TMOUTPOS);
34672     +   %if %superq(syshptmine) ne  %then %do;
34673     +      %let EMEXCEPTIONSTRING = EMTOOL.HPTMINE,%superq(syshptmine);
34674     +      %let syscc=0;
34675     +      %goto end_parse_train;
34676     +   %end;
34678     +   %else  %if %superq(sysdocparse) ne  %then %do;
34679     +      %let EMEXCEPTIONSTRING = EMTOOL.DOCPARSE,%superq(sysdocparse);
34680     +      %let syscc=0;
34681     +      %goto end_parse_train;
34682     +   %end;
34685     +    /* add rolestring and attrstring labels for  roles and strings to data set*/
34686     +    proc sql;
34689     +       create table &EM_USER_TERMS as
34690     +         select
34691     +            a.key label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_key_vlabel,NOQUOTE))",
34692     +            a.term label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_term_vlabel,NOQUOTE))",
34693     +            a.role,
34694     +            case a.role
34695     +               when 'Abbr'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posabbr_value,   NOQUOTE))"
34696     +               when 'Adj'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadj_value,   NOQUOTE))"
34697     +               when 'Adv'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadv_value,   NOQUOTE))"
34698     +               when 'Aux'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaux_value,   NOQUOTE))"
34699     +               when 'Conj'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posconj_value,   NOQUOTE))"
34700     +               when 'Det'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdet_value,   NOQUOTE))"
34701     +               when 'Interj'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinterj_value,   NOQUOTE))"
34702     +               when 'Noun'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoun_value,   NOQUOTE))"
34703     +               when 'Num'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnum_value,   NOQUOTE))"
34704     +               when 'Part'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospart_value,   NOQUOTE))"
34705     +               when 'Pref'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospref_value,   NOQUOTE))"
34706     +               when 'Prep'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprep_value,   NOQUOTE))"
34707     +               when 'Pron'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospron_value,   NOQUOTE))"
34708     +               when 'Prop'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprop_value,   NOQUOTE))"
34709     +               when 'Punct'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospunct_value,   NOQUOTE))"
34710     +               when 'Verb'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverb_value,   NOQUOTE))"
34711     +               when 'VerbAdj'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverbadj_value,   NOQUOTE))"
34712     +               when 'PERSON'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posperson_value,   NOQUOTE))"
34713     +               when 'ORGANIZATION'  then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posorganizationerson_value, NOQUOTE))"
34714     +               when 'LOCATION'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poslocation_value, NOQUOTE))"
34715     +               when 'COMPANY'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscompany_value,  NOQUOTE))"
34716     +               when 'TITLE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postitle_value,    NOQUOTE))"
34717     +               when 'PHONE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posphone_value,    NOQUOTE))"
34718     +               when 'DATE'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdate_value,     NOQUOTE))"
34719     +               when 'TIME'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postime_value,     NOQUOTE))"
34720     +               when 'INTERNET'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinternet_value, NOQUOTE))"
34721     +               when 'MEASURE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posmeasure_value,  NOQUOTE))"
34722     +               when 'NOUN_GROUP'    then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoungroup_value,  NOQUOTE))"
34723     +               when 'SSN'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posssn_value,        NOQUOTE))"
34724     +               when 'CURRENCY'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscurrency_value,   NOQUOTE))"
34725     +               when 'PERCENT'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospercent_value,    NOQUOTE))"
34726     +               when 'TIME_PERIOD'   then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postimeperiod_value, NOQUOTE))"
34727     +               when 'PROP_MISC'     then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospropmisc_value,   NOQUOTE))"
34728     +               when 'VEHICLE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posvehicle_value,    NOQUOTE))"
34729     +               when 'ADDRESS'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaddress_value,    NOQUOTE))"
34730     +               else              a.role
34731     +          end as rolestring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_role_vlabel,NOQUOTE))",
34732     +          a.attribute,
34733     +          case a.attribute
34734     +              when 'Alpha'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attralpha_value,   NOQUOTE))"
34735     +              when 'Mixed'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrmixed_value,   NOQUOTE))"
34736     +              when 'Num'           then    "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrnum_value,   NOQUOTE))"
34737     +              when 'Entity'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrentity_value,   NOQUOTE))"
34738     +               else             a.ATTRIBUTE
34739     +          end as attrstring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_attribute_vlabel,NOQUOTE))",
34740     +          /*No weight var at this point*/
34741     +           /*a.weight label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_weight_vlabel,NOQUOTE))" format=5.3,*/
34742     +           a.freq label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_freq_vlabel,NOQUOTE))",
34743     +           a.numdocs label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_numdocs_vlabel,NOQUOTE))",
34744     +           a.keep label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_keep_vlabel,NOQUOTE))",
34745     +           a._ispar label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_isparent_vlabel,NOQUOTE))",
34746     +           a.parent label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parent_vlabel,NOQUOTE))",
34747     +           a.parent_id label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parentid_vlabel,NOQUOTE))"
34748     +         from &EM_USER_TERMS  a;
34749     +    quit;
34750     +   data &EM_USER_tmconfig;
34751     +      length multiencoding $24 NG $3
34752     +         %if %superq(EM_PROPERTY_TGConcepts) ne %then %do;
34753     +         litilist $%eval(%klength(%superq(EM_PROPERTY_TGConcepts)) + 2 +
34754     +                       %klength(%superq(default_entity)))
34755     +            %end;
34756     +            ;
34757     +      set &EM_USER_tmconfig;
34759     +            parseVar = lowcase("&tm_parseVar");
34760     +            displayVar = lowcase("&tm_displayVar");
34761     +            indexpath = "&EM_NODEDIR.&EM_DSEP.";
34762     +            multiencoding="utf-8";
34763     +            %if %nrbquote(&filt) ne %then filterLangs="%nrbquote(&filt)"; %else filterLangs="";;
34765     +            /* Need to correct differences between hptmine and tgparse values for tmconfig
34766     +               table [cox] 11/24/2014  These may need to be changed again if we use
34767     +               proc hptmscore for scoring. */
34769     +            if NG="Y" then NG="STD"; else if NG="N" then NG="OFF";
34770     +            if entities="STD" then entities="Y";
34771     +            language=lowcase(language);
34772     +            %if %superq(EM_PROPERTY_TGConcepts) ne
34773     +               and ((&EM_PROPERTY_BPATTERNS eq CUSTOM and %upcase(&EM_PROPERTY_NOUNGROUPS) eq Y)
34774     +                    or &EM_PROPERTY_BPATTERNS eq ALL) %then %do;
34775     +                    litilist="%superq(EM_PROPERTY_TGConcepts)"||';'|| "%superq(default_entity)";
34776     +                    %end;
34777     +            %else %if &EM_PROPERTY_BPATTERNS eq CUSTOM %then %do;
34778     +               entities="Y";
34779     +               litilist="%superq(EM_PROPERTY_TGConcepts)";
34780     +               %end;
34782     +            run;
34785     +   /* Sort our terms data set and create an index for it
34786     +      Sort by term */
34787     +   proc sort data=&em_user_terms;
34788     +      %if %sysfunc(strip(&EM_PROPERTY_IGNOREPOS)) ne %then %do;
34789     +         by term role;
34790     +      %end;
34791     +      %else %do;
34792     +         by term;
34793     +      %end;
34794     +   run;
34796     +   /* Save the dataset information out to EMINFO */
34797     +   data &EM_DATA_EMINFO;
34798     +      length TARGET KEY $32 DATA $43;
34800     +      key="LastTMNode";
34801     +      data="&EM_NODEID";
34802     +      output;
34804     +      key="LastTMNodeType";
34805     +      data="TextParsing";
34806     +      output;
34808     +      key="LastTextParsing";
34809     +      data="&EM_NODEID";
34810     +      output;
34811     +    %if &filt ne %then %do;
34812     +          key="PRESCORECODE";
34813     +          data="&EM_NODEID";
34814     +          output;
34815     +    %end;
34816     +   run;
34820     +%end_parse_train:
34821     +   filename temp;
34822     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
34823     +   %if &tm_debug =0 %then %do;
34824     +      proc sql noprint;
34825     +         drop table internal_synds;
34826     +         drop table tm_languages;
34827     +         drop view _trainview;
34828     +      quit;
34829     +   %end;
34832     +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select data into :last_parse_node from EMWS1.Ids_EMINFO where key="LastTextParsing";
NOTE: No rows were selected.
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.parse_actions.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.PARSE_ACTIONS.SOURCE.
34833     +%macro openTable1();
34834     +/* initiate all possible tables if not already there*/
34836     +   %em_getname(key=synonymDS, type=data);
34837     +   %em_getname(key=multiDS, type=data);
34838     +   %em_getname(key=stopList, type=data);
34839     +   %em_getname(key=startList, type=data);
34841     +   /* set a macro for conditional Syn actions */
34842     +   %global tm_parse_action_syn;
34843     +   %let tm_parse_action_syn=1;
34845     +   %if ^%sysfunc(exist(&em_user_stoplist)) %then %do;
34846     +      proc sql noprint;
34847     +         create table &em_user_stopList
34848     +         (term char(256)
34849     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
34850     +          role char(256)
34851     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
34852     +             );
34853     +      quit;
34854     +      data &em_user_stoplist;
34855     +         format term $256.;
34856     +         set &em_user_stoplist &em_property_stoplist;
34857     +      run;
34858     +   %end;
34860     +   %if ^%sysfunc(exist(&em_user_synonymds)) %then %do;
34861     +      proc sql noprint;
34862     +         create table &em_user_synonymDS
34863     +         (term char(256)
34864     +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_term_vlabel, NOQUOTE))",
34865     +          termrole char(256)
34866     +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_termrole_vlabel, NOQUOTE))",
34867     +          parent char(256)
34868     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parent_vlabel, NOQUOTE))",
34869     +          parentrole char(256)
34870     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parentrole_vlabel, NOQUOTE))"
34871     +             );
34872     +      quit;
34873     +      data &em_user_synonymds;
34874     +         set &em_user_synonymDS &em_property_synonymds;
34875     +      run;
34876     +   %end;
34878     +   %if ^%sysfunc(exist(&em_user_multids)) %then %do;
34879     +      proc sql noprint;
34880     +         create table &em_user_multiDS
34881     +         (term char(256)
34882     +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_TERM_VLABEL, NOQUOTE))",
34883     +          role char(256)
34884     +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_ROLE_VLABEL, NOQUOTE))"
34885     +             );
34886     +       quit;
34888     +      data &em_user_multids;
34889     +         set &em_user_multids &em_property_multids;
34890     +      run;
34891     +   %end;
34893     +   %if ^%sysfunc(exist(&em_user_startList)) %then %do;
34894     +     proc sql noprint;
34895     +      create table &EM_USER_startList
34896     +         (term char(256)
34897     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
34898     +          role char(256)
34899     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
34900     +             );
34901     +    quit;
34902     +    data &em_user_startlist;
34903     +         set &em_user_startlist &em_property_startlist;
34904     +      run;
34906     +   %end;
34908     +%mend openTable1;
NOTE: %INCLUDE (level 1) ending.
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.getlanguages.source";
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.GETLANGUAGES.SOURCE.
34910     +data work.raw_tm_languages work.all_languages;
MPRINT(TRAIN):   data work.raw_tm_languages work.all_languages;
34911     +   length language $20;
MPRINT(TRAIN):   length language $20;
34912     +   input language $1-14 displaytext $15-69 prodnum;
MPRINT(TRAIN):   input language $1-14 displaytext $15-69 prodnum;
34913     +
34914     +   output work.all_languages;
MPRINT(TRAIN):   output work.all_languages;
34915     +   if prodnum = 0 or sysprod("PRODNUM"||left(trim(put(prodnum, 8.))))
34916     +        then output work.raw_tm_languages;
MPRINT(TRAIN):   if prodnum = 0 or sysprod("PRODNUM"||left(trim(put(prodnum, 8.)))) then output work.raw_tm_languages;
34917     +   drop prodnum;
MPRINT(TRAIN):   drop prodnum;
34918     +
34919     +   datalines;
MPRINT(TRAIN):   datalines;

NOTE: The data set WORK.RAW_TM_LANGUAGES has 2 observations and 2 variables.
NOTE: The data set WORK.ALL_LANGUAGES has 28 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):   ;
MPRINT(TRAIN):   run;
34948     +;
34949     +run;
34950     +
34951     +
34952     +
34953     +
34954     +proc sql noprint;
MPRINT(TRAIN):   proc sql noprint;
34955     +   create table work.tm_languages as
34956     +      select distinct(language), displaytext
34957     +      from work.raw_tm_languages;
MPRINT(TRAIN):   create table work.tm_languages as select distinct(language), displaytext from work.raw_tm_languages;
NOTE: Table WORK.TM_LANGUAGES created, with 2 rows and 2 columns.

34958     +   create table work.all_tm_languages as
34959     +      select distinct(language), displaytext
34960     +      from work.all_languages;
MPRINT(TRAIN):   create table work.all_tm_languages as select distinct(language), displaytext from work.all_languages;
NOTE: Table WORK.ALL_TM_LANGUAGES created, with 27 rows and 2 columns.

34961     +   drop table work.raw_tm_languages;
MPRINT(TRAIN):   drop table work.raw_tm_languages;
NOTE: Table WORK.RAW_TM_LANGUAGES has been dropped.
34962     +   drop table work.all_languages;
MPRINT(TRAIN):   drop table work.all_languages;
NOTE: Table WORK.ALL_LANGUAGES has been dropped.
34963     +quit;
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.08 seconds
      cpu time            0.04 seconds
      

34964     +
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select language into :found_language from work.tm_languages where upcase("ENGLISH") eq upcase(language);
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.tm_parse.source";
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TM_PARSE.SOURCE.
34965     +/* ****************************************************************
34966     + * Name:    tmparse (macro)
34967     + *
34968     + * Support: Jim Cox
34969     + *
34970     + * Usage: %tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,keyvar=_document_,
34971     + *                var=,docidvar=, filevar=,config=,
34972     + *                stemming=Y,tagging=Y,ng=Y,entities=NONE,
34973     + *                stoplist=, startlist=, inkey=,doc_id=,
34974     + *                posignore=, entignore=,entkeep=, attribignore=,
34975     + *                reducef=1,termwgt=,cellwgt=,
34976     + *                language=english, multisyn=, nopos=, TGConcepts=,
34977     + *                TGCategories=, indexDir=,out_parent=,
34978     + *                delimit=Formal,outpos=,filterds=,filterstatus=drop);
34979     + * Purpose: To run Text parsing
34980     + *
34981     + * Parms:
34982     + * inds=<dataset> Specifies the input document dataset. This ds has a variable containing
34983     + *      the actual text or a path to the actual text.
34984     + * outds=<dataset> The output OUT table containing variables _TERMNUM_,
34985     + *      _DOCUMENT_,ENTRY. This represents the output term-by- document
34986     + *      frequency matrix.
34987     + * keyds=<dataset> Species the output terms table of terms with their
34988     + *      assoiciated KEY(numeric id) and summary statistics
34989     + * synds=<dataset> An input data set for applying user defined synonyms.
34990     + *      The dataset should contain variables TERM and PARENT and
34991     + *      optionally TERMROLE and PARENTROLE. All occurrences in the text of
34992     + *      matching strings for the term will be assigned the associated parent.
34993     + * keyvar=_document_
34994     + * var=<variable name> Specifies the variable on the inds dataset
34995     + *      that contains the text to be parsed.
34996     + * docidvar=<variable name> This specifies an integer valued variable
34997     + *      that must be on the inds document table. Rather than indexing documents
34998     + *      from 1 to n, this optional setting allow you to control what
34999     + *      id values for documents are used on the OUTds table
35000     + * filevar= Instead of var=, this speicifies the variable on the inds dataset
35001     + *      that contains a path to the plain text documents to be parsed.
35002     + * config=<dataset> An output and an input dataset containing the settings specfied
35003     + *      on this run. If the config exists when specified, the settings
35004     + *      found in the config file will override settings on this macro.
35005     + * stemming=<Y or N> Determines if terms will be stemmed to their root forms.
35006     + * tagging=<Y or N> Determines if the parsed terms will be assigned a
35007     + *      part-of-speech tag.
35008     + * ng=<Y or N> Determines if noun groups will be found as terms.
35009     + * entities=<NONE,DEFAULT, CUSTOM, ALL> Controls if entities are
35010     + *      found during the parse
35011     + *      NONE - do not find entities
35012     + *      DEFAULT - Identify the standard entities
35013     + *      CUSTOM - Use a customizeed file to extract user-specific
35014     + *               entities
35015     + *      ALL - identify the standard entities and extract user-specific entities.
35016     + * stoplist= <dataset> Provide an input list of terms to stop. Variables
35017     + *       are TERM and optionally TERMROLE
35018     + * startlist=<dataset> Provide an input list of terms to keep (all others
35019     + *       will be stopped). Variables are TERM and optionally TERMROLE
35020     + * inkey= <dataset> This option is there to support iterative parsing
35021     + *      It controls the numbering of terms.  The data set inkey comes
35022     + *      from a previous parse and proc tgparse uses the term keys found
35023     + *      there so that identical terms will receive the same key as a previous
35024     + *      parse.
35025     + * doc_id=<nonneg integer>  This also supports iterative parsing and tells
35026     + *      tgparse to start numbering docs at Doc_id rather than with a 1.
35027     + * posignore="POS1" "POS2" .... Allows user to specify a list of part-of-
35028     + *      speech tags. Any terms with these tags will be removed.
35029     + *      For example  posignore="DET" "PREP"
35030     + * entignore="ENT1" "ENT2"... Allows user to specify a list of entity
35031     + *      types. Any terms with these tags will be removed.
35032     + *      For example  entignore="COMPANY" "PRODUCT"
35033     + * entkeep="ENT1" "ENT2" ... Allows user to specify a list of entity
35034     + *      types. Any terms with these tags will be kept and all others
35035     + *       remove. *      For example  entkeep="COMPANY" "PRODUCT"
35036     + * attribignore="ATTRIB1" "ATTRIB2"...Allows user to specify a list of
35037     + *      attributes. Any terms with these attribues will be removed.
35038     + *      For example  posignore="NUM" "PUNCT"
35039     + * reducef=<Positive Integer> Setting lets you specify when to dynamically
35040     + *      stop terms from the analysis. They must appear in at least
35041     + *      reducef documents in order to be kept.
35042     + * termwgt=<NONE, ENTROPY, oR MI> Specify the term weight for each term
35043     + * cellwgt=<NONE or LOG> Specify the cell weight for terms
35044     + * language=<english> Specify the langugage of the text you are parsing
35045     + * multisyn=<filename> Specify the path to a custom multiword term file.
35046     + * nopos=
35047     + * TGConcepts=<filename> Specify the location of custom concept definition
35048     + *       file
35049     + * TGCategories= IGNORED CURRENTLY
35050     + * indexDir= The output location of the search index that can be built with the
35051     + *    input document data.
35052     + * out_parent= An output term-document table that has all children's
35053     + *    (from stemming and synonyms )frequencies
35054     + *    replaced and attributed to their parents. This is the representative form
35055     + *    for the parse collection
35056     + * delimit=Formal IGNORED CURRENTLY
35057     + * outpos=<dataset> An output dataset containing the offset information of
35058     + *    every term in the collection.
35059     + * filterds=<dataset> The name of the dataset of terms used for filtering.
35060     + *        This data set can be used to set terms to keep or drop based
35061     + *        on the filterstatus setting.
35062     + * filterstatus=drop
35063     + * langchk=yes
35064     + *
35065     + * Returns:
35066     + *
35067     + * History:
35068     + * 01Dec05 Initial Coding [cox]
35069     + *
35070     + *
35071     + * Notes:
35072     + * Last Modified By:
35073     + * Last Modified On: Thu Mar 26 13:24:22 2015
35074     + * End
35075     + * ************************************************************** */
35077     +%macro tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,docidvar=_document_,
35078     +                 var=, filevar=, config=,
35079     +                 stemming=Y,tagging=Y,ng=Y,entities=NONE,
35080     +                 stoplist=, startlist=, inkey=,doc_id=,reducef=1,termwgt=,cellwgt=,
35081     +                 posignore=, entignore=,entkeep=, attribignore=,
35082     +                 language=english, multisyn=, nopos=, TGConcepts=,
35083     +                 TGCategories=, indexDir=,out_parent=, langchk=yes,
35084     +                 delimit=Formal,outpos=,filterds=,filterstatus=drop);
35086     +%global default_entity;
35087     +%let language=%lowcase(&language);
35088     +%let attribtest=%upcase(&attribignore);
35089     +%let filterstatus=%upcase(&filterstatus);
35090     +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
35091     +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
35092     +%if &tm_hptmineBuildIndex ne 1 %then %let tm_hptmineBuildIndex=0;
35095     +/* Now do tests to determine which proc we will run */
35096     +%if &tm_hptmineBuildIndex=0 and %nrbquote(&indexDir) ne %then %let parse_proc=tgparse;
35098     +/* if asked to select/drop entities or pos also use tgparse
35099     +    [cox] No longer true so removing condition 9/4/2014 */
35100     +/* %else %if &posignore ne or &entignore ne or &entkeep ne
35101     +    %then %let parse_proc=tgparse;
35102     +*/
35104     +/* otherwise, if language not English or German, use tgparse */
35105     +%else %if &language ne english and &language ne german and
35106     +   &language ne chinese and &language ne spanish and
35107     +   &language ne italian and &language ne portuguese and
35108     +   &language ne dutch and &language ne korean and
35109     +   &language ne french and &language ne russian and
35110     +   &language ne finnish and &language ne turkish
35111     +   and &language ne japanese  and &langchk = yes
35112     + %then %let parse_proc=tgparse;
35114     +/* Otherwise, attribignore must contain NUM and PUNCT but not ABBR, ALPHA, or MIXED
35115     +  [cox] No longer true so removing condition 9/4/2014
35116     +  */
35117     +/*
35118     +%else %if %index(&attribtest, NUM) eq 0 or %index(&attribtest, PUNCT) eq 0 or
35119     +   %index(&attribtest, ABBR) ne 0 or %index(&attribtest, ALPHA) ne 0 or
35120     +   %index(&attribtest, MIXED) ne 0 %then %let parse_proc=tgparse;
35121     +*/
35123     +/* finally, must not be updating a previously generated key table */
35125     +%else %if &inkey ne %then %let parse_proc=tgparse;
35126     +   %else %let parse_proc=hptmine;
35128     +   /* delete the tmconfig file so we do not use another tmconfig from a previous node */
35129     +   %if &config ne %then %do;
35130     +      proc sql noprint;
35131     +         drop table &config;
35132     +      quit;
35133     +   %end;
35136     +   /* fix quote problems (replace single quote with double quotes) in posignore=,
35137     +      entignore=, attribignore= .  What about entkeep= (cox)? */
35138     +   data _null_;
35139     +      %if %ktrim(&posignore) ne %then %do;
35140     +         posignore = "&posignore";
35141     +         posignore = transtrn(posignore, "'", '"');
35142     +         call symput("posignore", posignore);
35143     +      %end;
35144     +      %if %ktrim(&entignore) ne %then %do;
35145     +         entignore = "&entignore";
35146     +         entignore = transtrn(entignore, "'", '"');
35147     +         call symput("entignore", entignore);
35148     +      %end;
35149     +      %if %ktrim(&attribignore) ne %then %do;
35150     +         attribignore = "&attribignore";
35151     +         attribignore = transtrn(attribignore, "'", '"');
35152     +         call symput("attribignore", attribignore);
35153     +      %end;
35154     +   run;
35156     +   %let stoplist_count = 0;
35157     +   %let startlist_count = 0;
35158     +   %let synds_count = 0;
35159     +   proc sql noprint;
35160     +      %if "&stoplist" ne "" %then %do;
35161     +         select count(*) into :stoplist_count
35162     +         from &stoplist;
35163     +      %end;
35164     +      %if "&startlist" ne "" %then %do;
35165     +         select count(*) into :startlist_count
35166     +         from &startlist;
35167     +      %end;
35168     +      %if "&synds" ne "" %then %do;
35169     +         select count(*) into :synds_count
35170     +         from &synds;
35171     +      %end;
35172     +   quit;
35174     +   /* control behavior of custom entities */
35175     +   %if &parse_proc eq tgparse %then %let ent_true=yes; %else %let ent_true=std;
35176     +   %if &parse_proc eq tgparse %then %let ent_false=no; %else %let ent_false=none;
35177     +   %let entity_info = ;
35178     +   %if &entities eq NONE %then %do;
35179     +      %let entity_info = entities=&ent_false ;
35180     +      %let entignore = ; %let entkeep=;
35181     +   %end;
35182     +   %else %if &entities eq DEFAULT %then %do;
35183     +      %let entity_info = entities=&ent_true ;
35184     +   %end;
35185     +   /* Otherwise entities are CUSTOM or ALL */
35186     +   %else %do;
35187     +      /* Need to set up default entities if NG on or entities set to ALL */
35188     +      %if &entities eq ALL or %upcase(&ng) eq Y %then %do;
35189     +      %let default_entity = %sysfunc(pathname(SASROOT))&EM_DSEP ;
35191     +      %if "&EM_DSEP" eq "/" %then %do;
35192     +         /* unix */
35193     +         %let default_entity = &default_entity.misc&EM_DSEP.tktg&EM_DSEP. ;
35194     +         %end;
35195     +      %else %if "&EM_DSEP" eq "\" %then %do;
35196     +         /* windows */
35197     +         %let default_entity = &default_entity.tktg&EM_DSEP.sasmisc&EM_DSEP. ;
35198     +         %end;
35199     +      %let entity_language = %lowcase(&language);
35201     +      %if "&entity_language" eq "arabic" %then %do;
35202     +         %let default_entity = &default_entity.ar-ne.li ;
35203     +         %end;
35204     +      %else %if "&entity_language" eq "german" %then %do;
35205     +         %let default_entity = &default_entity.de-ne.li ;
35206     +         %end;
35207     +      %else %if "&entity_language" eq "english" %then %do;
35208     +         %let default_entity = &default_entity.en-ne.li ;
35209     +         %end;
35210     +      %else %if "&entity_language" eq "spanish" %then %do;
35211     +         %let default_entity = &default_entity.es-ne.li ;
35212     +         %end;
35213     +      %else %if "&entity_language" eq "french" %then %do;
35214     +         %let default_entity = &default_entity.fr-ne.li ;
35215     +         %end;
35216     +      %else %if "&entity_language" eq "italian" %then %do;
35217     +         %let default_entity = &default_entity.it-ne.li ;
35218     +         %end;
35219     +      %else %if "&entity_language" eq "japanese" %then %do;
35220     +         %let default_entity = &default_entity.jp-ne.li ;
35221     +         %end;
35222     +      %else %if "&entity_language" eq "korean" %then %do;
35223     +         %let default_entity = &default_entity.kr-ne.li ;
35224     +         %end;
35225     +      %else %if "&entity_language" eq "dutch" %then %do;
35226     +         %let default_entity = &default_entity.nl-ne.li ;
35227     +         %end;
35228     +      %else %if "&entity_language" eq "polish" %then %do;
35229     +         %let default_entity = &default_entity.pl-ne.li ;
35230     +         %end;
35231     +      %else %if "&entity_language" eq "portuguese" %then %do;
35232     +         %let default_entity = &default_entity.pt-ne.li ;
35233     +         %end;
35234     +      %else %if "&entity_language" eq "chinese" %then %do;
35235     +         %let default_entity = &default_entity.zh-ne.li ;
35236     +         %end;
35237     +      %else %if "&entity_language" eq "russian" %then %do;
35238     +         %let default_entity = &default_entity.ru-ne.li ;
35239     +         %end;
35240     +      %else %if "&entity_language" eq "turkish" %then %do;
35241     +         %let default_entity = &default_entity.tr-ne.li ;
35242     +         %end;
35243     +      %else %if "&entity_language" eq "thai" %then %do;
35244     +         %let default_entity = &default_entity.th-ne.li ;
35245     +         %end;
35246     +      %else %if "&entity_language" eq "vietnamese" %then %do;
35247     +         %let default_entity = &default_entity.vi-ne.li ;
35248     +         %end;
35249     +      %else %if "&entity_language" eq "norwegian" %then %do;
35250     +         %let default_entity = &default_entity.no-ne.li ;
35251     +         %end;
35252     +      %else %if "&entity_language" eq "danish" %then %do;
35253     +         %let default_entity = &default_entity.da-ne.li ;
35254     +         %end;
35255     +      %else %if "&entity_language" eq "greek" %then %do;
35256     +         %let default_entity = &default_entity.el-ne.li ;
35257     +         %end;
35258     +      %else %if "&entity_language" eq "romanian" %then %do;
35259     +         %let default_entity = &default_entity.ro-ne.li ;
35260     +         %end;
35261     +      %else %if "&entity_language" eq "hebrew" %then %do;
35262     +         %let default_entity = &default_entity.he-ne.li ;
35263     +         %end;
35264     +      %else %if "&entity_language" eq "czech" %then %do;
35265     +         %let default_entity = &default_entity.cs-ne.li ;
35266     +         %end;
35267     +      %else %if "&entity_language" eq "slovak" %then %do;
35268     +         %let default_entity = &default_entity.sk-ne.li ;
35269     +         %end;
35270     +      %else %if "&entity_language" eq "hungarian" %then %do;
35271     +         %let default_entity = &default_entity.hu-ne.li ;
35272     +         %end;
35273     +      %else %if "&entity_language" eq "indonesian" %then %do;
35274     +         %let default_entity = &default_entity.id-ne.li ;
35275     +         %end;
35276     +      %else %if "&entity_language" eq "finnish" %then %do;
35277     +         %let default_entity = &default_entity.fi-ne.li ;
35278     +         %end;
35279     +      %else %let default_entity=&ent_false;
35281     +         %end;
35283     +   %if &entities eq CUSTOM %then %do;
35284     +      %if %superq(TGConcepts) ne %then %do;
35285     +         %if &parse_proc eq tgparse %then %let ent_flag=&ent_true;
35286     +         %else %let ent_flag=&ent_false;
35287     +         %let entity_info = entities=&ent_flag litilist=("&TGConcepts") ;
35288     +      %end;
35289     +      %else %do;
35290     +         %let entity_info = entities=&ent_false ;
35291     +      %end;
35293     +      /* %let entignore = ; */
35294     +      %end;
35295     +   %else %if &entities eq ALL %then %do;
35297     +      %if %nrbquote(&TGConcepts) ne %then %do;
35298     +         %if &parse_proc eq tgparse %then
35299     +            %let entity_info= entities=&ent_true litilist=("&default_entity" "&TGConcepts") ;
35300     +         %else %let entity_info= entities=&ent_true litilist=("&TGConcepts") ;
35301     +         %end;
35302     +      %else %let entity_info= entities=&ent_true;
35305     +      %end;
35307     +%end;
35309     +   /* main docparse call */
35310     +%if &parse_proc eq tgparse %then %do;
35311     +      proc tgparse data=&inds key=&keyds out=&outds
35312     +         %if &filterds ne %then %do;
35313     +            %if %upcase(&filterstatus) eq DROP %then stop=&filterds;
35314     +            %else %if %upcase(&filterstatus) eq KEEP %then start=&filterds;
35315     +            %else %if %upcase(&filterstatus) eq IGNORE %then ignore=&filterds;
35316     +            %else %if %upcase(&filterstatus) eq RETAIN %then retain=&filterds;
35317     +            %end;
35318     +         %if &config ne %then config=&config;
35319     +         %if &nopos ne %then NOPOS;
35320     +         %if &synds_count ne 0 %then syn=&synds;
35321     +         %if "&multisyn" ne "" %then multiterm="&multisyn";
35322     +         %if %upcase(&stemming) eq Y %then stemming=yes ; %else stemming=no ;
35323     +         %if %upcase(&tagging) eq Y %then tagging=yes ; %else tagging=no ;
35324     +         &entity_info
35325     +         /* %if "%trim(%left(&TGCategories))" ne "" %then TGCategories=&TGCategories ; */
35326     +         %if "%nrbquote(&indexDir)" ne "" %then %do;
35327     +            buildindex=yes
35328     +            indexpath="%nrbquote(&indexDir)"
35329     +         %end;
35330     +         %if &stoplist_count ne 0  %then stop=&stoplist;
35331     +         %else %if &startlist_count ne 0  %then start=&startlist;
35332     +         %if %upcase(&ng) eq Y %then ng=std ;
35333     +         %else ng=off ;
35334     +         %if &filevar ne %then namedfile;
35335     +         %if %lowcase(&language) ne other %then language=%lowcase(&language);
35336     +         %else plugin="SAS";
35337     +         %if &outpos ne %then %do; outoffset=&outpos addsentence addparagraph %end;
35338     +         %if &inkey ne %then  inkey=&inkey;
35339     +         %if &doc_id ne %then doc_id=&doc_id;
35341     +         ;
35342     +      var %if &filevar ne %then &filevar; %else &var; ;
35343     +      %if %upcase(&docidvar) ne _DOCUMENT_ %then id &docidvar;;
35345     +      select &posignore "Newline" / drop;
35346     +      %if &attribignore ne %then select &attribignore / group="attributes" drop; ;
35347     +      %if &entkeep ne and &entignore =  %then %do;
35348     +          select &entkeep / group="entities" keep;
35349     +      %end;
35350     +      %else %do;
35351     +          %if &entignore ne %then select &entignore / group="entities" drop; ;
35352     +      %end;
35353     +      run;
35354     +%end;
35356     +%else %do;
35358     +proc hptmine data=&inds language=&language;
35359     +    var %if &filevar ne %then &filevar; %else &var; ;
35360     +   doc_id &docidvar;
35361     +   parse reducef=&reducef outterms=&keyds
35362     +      %if &filevar ne %then namedfile;
35364     +      %if &filterds ne %then %do;
35365     +          %if %upcase(&filterstatus) eq DROP or %upcase(&filterstatus) eq IGNORE
35366     +             %then stop=&filterds;
35367     +          %else %if %upcase(&filterstatus) eq KEEP or %upcase(&filterstatus) eq RETAIN
35368     +             %then start=&filterds;
35369     +          %if %upcase(&filterstatus) ne IGNORE and %upcase(&filterstatus) ne RETAIN
35370     +             %then showdroppedterms;
35371     +      %end;
35372     +      %else showdroppedterms;
35374     +      %if &termwgt ne %then termwgt=&termwgt;
35375     +      %if &cellwgt ne %then cellwgt=&cellwgt;
35376     +      %if %upcase(&stemming) ne Y %then nostemming;
35377     +      %if %upcase(&tagging) ne Y %then notagging;
35378     +      %if %upcase(&ng) ne Y %then nonoungroups;
35379     +   %if &stoplist_count ne 0  %then stop=&stoplist;
35380     +   %else %if &startlist_count ne 0  %then start=&startlist;
35381     +%if 0 %then %do;
35382     +%end;
35383     +      %if &synds_count ne 0 %then syn=&synds;
35384     +         &entity_info
35385     +      %if "&multisyn" ne "" %then multiterm="&multisyn";
35386     +      %if "%nrbquote(&indexDir)" ne "" %then %do;
35387     +            buildindex
35388     +            indexpath="%nrbquote(&indexDir)"
35389     +      %end;
35391     +      %if &outds ne %then outchild=&outds;
35392     +      %if &outpos ne %then outpos=&outpos;
35393     +      %if &config ne %then outconfig=&config;
35394     +      %if &out_parent ne %then outparent=&out_parent;
35396     +   ;
35397     +     %if &posignore ne %then select &posignore "Newline" / ignore; ;
35398     +        %if &attribignore eq %then %let attribignore="";
35399     +      select &attribignore / group="attributes" ignore;
35400     +      %if &entkeep ne and &entignore =  %then %do;
35401     +         select &entkeep / group="entities" keep; ;
35402     +      %end;
35403     +      %else %do;
35404     +          %if &entignore ne %then select &entignore / group="entities" ignore; ;
35405     +      %end;
35406     +      performance /* nthreads=1 */ details;
35407     +   run;
35408     +%if %symexist(syshptmine) %then %let sysdocparse=&syshptmine;
35409     +%else %let sysdocparse=;
35411     +/* Change term and outpos tables so that they correspond to tgparse variable names */
35414     +/* Change term and outpos tables so that they correspond to tgparse variable names */
35415     +proc sql noprint;
35416     +   create table &keyds as select *,_keep as keep from &keyds
35417     +      order by _keep desc,numdocs desc;
35418     +  %if &outpos ne %then %do;
35419     +     create table tempKey as select
35420     +        a.key as _termnum_,
35421     +        a.term,
35422     +        a.role
35423     +        from &keyds a
35424     +        where a._ispar ne '+';
35426     +     create table tempoutpos as select
35427     +        a.document as _document_,
35428     +        a.sentence as _sentence_,
35429     +        a._start_ as _offset_,
35430     +        a._end_ - a._start_+1 as _length_,
35431     +        b._termnum_
35432     +        from &outpos as a , tempKey as b
35433     +        where b.term=a.term and b.role=a.role;
35435     +     create table tempoutds as select
35436     +        a.*
35437     +        from &outds as a, tempkey as b
35438     +        where a._termnum_= b._termnum_;
35440     +      create table &outpos as select
35441     +        a._document_,
35442     +        a._sentence_,
35443     +        a._offset_,
35444     +        a. _length_,
35445     +        a._termnum_,
35446     +        b._count_
35447     +        from tempoutpos as a, tempoutds as b
35448     +        where a._termnum_=b._termnum_ and a._document_ =b._document_;
35450     +       drop table tempoutpos;
35451     +       drop table tempKey;
35452     +     %end;
35453     +     /* improve tmutil performance*/
35454     +     proc sort data=&outds;
35455     +       by _termnum_ _document_;
35456     +     run;
35457     +  quit;
35459     +%end;
35461     +%end_tmparse:
35463     +%mend;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.tmwritemulti.source";
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TMWRITEMULTI.SOURCE.
35464     +/* ****************************************************************
35465     + * Name:    tmwritemulti.sas (macro)
35466     + *
35467     + *
35468     + * Usage: %tmwritemulti(multids=, stopds=, startds=, synds=, multi=);
35469     + * Purpose: To write out the text file for the multiword dictionary.  This will
35470     + *  include multiword term in the data= file as well as
35471     + * Parameters
35472     + * multids   = data set with multiword terms and their roles
35473     + * stopds    = stop word list - look for multiword terms
35474     + * startds   = start word list - look for multiword terms
35475     + * synds     = data set with synonyms and their roles
35476     + * multi     = multiterm text file.
35477     + * End
35478     + * ************************************************************** */
35479     +
35480     +
35481     +%macro tmwritemulti(multids=, stopds=, startds=, synds=, multi=, multidsout=);
35482     +
35483     +   * create a multiword terms data set ;
35484     +   proc sql noprint;
35485     +      create table _multiterms_
35486     +         (term   char(256),
35487     +          role   char(256));
35488     +   quit;
35489     +
35490     +   %let synds_count = ;
35491     +   %let stopds_count = ;
35492     +   %let startds_count = ;
35493     +   %let multids_count = ;
35494     +   proc sql noprint;
35495     +      select count(*) into :synds_count
35496     +      from &synds;
35497     +
35498     +      select count(*) into :stopds_count
35499     +      from &stopds;
35500     +
35501     +      %if &startds ne %then
35502     +      select count(*) into :startds_count
35503     +      from &startds;
35504     +      %else %let startds_count = 0;;
35505     +
35506     +      select count(*) into :multids_count
35507     +      from &multids;
35508     +   quit;
35509     +
35510     +   * check the synonym ds for multiword terms ;
35511     +   %if &synds_count ne 0 %then %do;
35512     +      %find_multiword_terms(data_in=&synds, data_append=_multiterms_);
35513     +   %end;
35514     +
35515     +   * check the stopTerms ds for multiword terms ;
35516     +   %if &stopds_count ne 0 %then %do;
35517     +      %find_multiword_terms(data_in=&stopds, data_append=_multiterms_);
35518     +   %end;
35519     +
35520     +   * check the startTerms ds for multiword terms;
35521     +   %if &startds_count ne 0 %then %do;
35522     +      %find_multiword_terms(data_in=&startds, data_append=_multiterms_);
35523     +   %end;
35524     +
35525     +   * check the multids for multiword terms ;
35526     +   %if &multids_count ne 0 %then %do;
35527     +      data work.multids_temp;
35528     +         length term $256 role $256;
35529     +         set &multids;
35530     +         if role eq '' then role='Noun';
35531     +      run;
35532     +      proc append base=_multiterms_ data=work.multids_temp(keep=term role) force;
35533     +      run;
35534     +      proc sql noprint;
35535     +         drop table work.multids_temp;
35536     +      run;
35537     +   %end;
35538     +
35539     +   * add lower and upper case variations to the multi word terms ;
35540     +
35541     +   data _multiterms_;
35542     +      set _multiterms_;
35543     +      term = transtrn(term, ':', '\:');
35544     +
35545     +      * output exactly as is ;
35546     +      output;
35547     +      * output lower case versions ;
35548     +      term=lowcase(term);
35549     +      output;
35550     +      * output upper case versions ;
35551     +      term=upcase(term);
35552     +      output;
35553     +      * output uppercase first letter of each term, lower rest ;
35554     +      term = propcase(term);
35555     +      output;
35556     +   run;
35557     +
35558     +   * remove duplicate term entries ;
35559     +   proc sort data= _multiterms_ nodupkey;
35560     +      by term role;
35561     +   run;
35562     +
35563     +   filename _multout "&multi";
35564     +
35565     +   * write out all the multiword terms ;
35566     +   data &multidsout;
35567     +      set _multiterms_;
35568     +      file _multout encoding="utf-8";
35569     +      put term ':3:' role;
35570     +   run;
35571     +
35572     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
35573     +   %if &tm_debug =0 %then %do;
35574     +      proc sql noprint;
35575     +         drop table work._multiterms_;
35576     +      quit;
35577     +   %end;
35578     +
35579     +%mend tmwritemulti;
35580     +
35581     +
35582     +/*
35583     +
35584     +%tmwritemulti(language="english", data=sashelp.engsynms);
35585     +
35586     +*/
35587     +
35588     +%macro find_multiword_terms(data_in=, data_append=);
35589     +
35590     +   data &data_in._temp (keep=term role);
35591     +      length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
35592     +
35593     +      set &data_in;
35594     +
35595     +      if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
35596     +         if childrole ne '' then category = childrole;
35597     +         if role ne '' then category = role;
35598     +
35599     +         if lowcase(category) eq category then category=propcase(category) ;
35600     +
35601     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
35602     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
35603     +         else if category eq '' then role='Noun';
35604     +         else role = 'Prop';
35605     +
35606     +         output;
35607     +      end;
35608     +
35609     +      if "&data_in"="&synds" and anypunct(term,1) > 0 then do;
35610     +         term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
35611     +         if role ne '' then category = role;
35612     +
35613     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
35614     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
35615     +         else if category eq '' then role='Noun';
35616     +         else role = 'Prop';
35617     +
35618     +         output;
35619     +      end;
35620     +
35621     +      if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
35622     +         term = parent;
35623     +         if parentrole ne '' then category = childrole;
35624     +
35625     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
35626     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
35627     +         else if category eq '' then role='Noun';
35628     +         else role = 'Prop';
35629     +         output;
35630     +      end;
35631     +   run;
35632     +
35633     +   proc append base=&data_append data=&data_in._temp force;
35634     +   run;
35635     +
35636     +   proc sql noprint;
35637     +      drop table &data_in._temp;
35638     +   quit;
35639     +%mend find_multiword_terms;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   length parsevar urivar filteredvar $32;
MPRINT(TRAIN):   retain max_len 0;
MPRINT(TRAIN):   retain parsevar '';
MPRINT(TRAIN):   retain urivar '';
MPRINT(TRAIN):   retain filteredvar '';
MPRINT(TRAIN):   set EMWS1.TextParsing_VariableSet end=eof;
MPRINT(TRAIN):   if upcase(ROLE)='TEXT' and USE in ('Y', 'D') and length > max_len then do;
MPRINT(TRAIN):   parsevar = name;
MPRINT(TRAIN):   max_len = length;
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   if upcase(ROLE)='TEXTLOC' and USE in ('D', 'Y') then filteredvar = name;
MPRINT(TRAIN):   if ROLE='URIVAR' and USE in ('D', 'Y') then urivar = name;
MPRINT(TRAIN):   if eof then do;
MPRINT(TRAIN):   call symput('tm_parsevar', parsevar);
MPRINT(TRAIN):   call symput('tm_urivar', urivar);
MPRINT(TRAIN):   call symput('tm_filteredvar', filteredvar);
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS1.TEXTPARSING_VARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PROPERTYCHANGE):   data WORK.EM_USER_PROPERTY;
MPRINT(EM_PROPERTYCHANGE):   length NAME $32 VALUE $400;
MPRINT(EM_PROPERTYCHANGE):   NAME = "parseVar";
MPRINT(EM_PROPERTYCHANGE):   VALUE = "AdjusterNotes";
MPRINT(EM_PROPERTYCHANGE):   output;
MPRINT(EM_PROPERTYCHANGE):   run;

NOTE: The data set WORK.EM_USER_PROPERTY has 1 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PROPERTYCHANGE):   run;
MPRINT(TRAIN):  ;
*------------------------------------------------------------*
NOTE: Variable used for parsing is: AdjusterNotes
*------------------------------------------------------------*
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid=open("EMWS1.TextParsing_synonymDS");
MPRINT(TRAIN):   check=varnum(dsid,'category');
MPRINT(TRAIN):   if check ne 0 then call symput('category_exists', '1');
MPRINT(TRAIN):   check=varnum(dsid,'termrole');
MPRINT(TRAIN):   if check ne 0 then call symput('termrole_exists', '1');
MPRINT(TRAIN):   check=varnum(dsid,'parentrole');
MPRINT(TRAIN):   if check ne 0 then call symput('parentrole_exists', '1');
MPRINT(TRAIN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table work.internal_synds as select term, parent, termrole, parentrole from EMWS1.TextParsing_synonymDS;
NOTE: Table WORK.INTERNAL_SYNDS created, with 1 rows and 4 columns.

MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data work.internal_synds;
MPRINT(TRAIN):   set work.internal_synds;
MPRINT(TRAIN):   if KUPCASE(termrole) in ('PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE', 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS', 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD' ) then 
termrole=KUPCASE(termrole);
MPRINT(TRAIN):   if KUPCASE(parentrole) in ('PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE', 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS', 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD') then 
parentrole=KUPCASE(parentrole);
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set WORK.INTERNAL_SYNDS has 1 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=work.internal_synds nodupkey;
MPRINT(TRAIN):   by term parent termrole parentrole ;
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.INTERNAL_SYNDS has 1 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select count(*) into :stoplist_count from EMWS1.TextParsing_stopList;
MPRINT(TRAIN):   select count(*) into :startlist_count from EMWS1.TextParsing_startList;
MPRINT(TRAIN):   create view _trainview as select * from EMWS1.Part_TRAIN;
NOTE: SQL view WORK._TRAINVIEW has been defined.
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.06 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid=open("EMWS1.TextParsing_stopList");
MPRINT(TRAIN):   check=varnum(dsid,'role');
MPRINT(TRAIN):   if check ne 0 then call symput('role_exists', '1');
MPRINT(TRAIN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS1.TextParsing_stopList nodupkey;
MPRINT(TRAIN):   by term role;
MPRINT(TRAIN):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data EMWS1.TextParsing_TRAIN(compress=yes);
MPRINT(TRAIN):   set _trainview;
MPRINT(TRAIN):   _document_ = _n_;
MPRINT(TRAIN):   label _document_= "Document";
MPRINT(TRAIN):   run;

NOTE: There were 302 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 302 observations read from the data set WORK._TRAINVIEW.
NOTE: The data set EMWS1.TEXTPARSING_TRAIN has 302 observations and 9 variables.
NOTE: Compressing data set EMWS1.TEXTPARSING_TRAIN decreased size by 0.00 percent. 
      Compressed is 2 pages; un-compressed would require 2 pages.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   length KEY $32 DELETE $1 UNAME $32 ROLE $32 LEVEL $10 ORDER $8 COMMENT $64 LOWERLIMIT 8 UPPERLIMIT 8;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("_document_");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("ID");
MPRINT(EM_METACHANGE):   LEVEL = upcase("NOMINAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   run;

NOTE: The data set WORK.EM_METACHANGE has 1 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TMWRITEMULTI):   * create a multiword terms data set ;
MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   create table _multiterms_ (term char(256), role char(256));
NOTE: Table WORK._MULTITERMS_ created, with 0 rows and 2 columns.
MPRINT(TMWRITEMULTI):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   select count(*) into :synds_count from work.internal_synds;
MPRINT(TMWRITEMULTI):   select count(*) into :stopds_count from EMWS1.TextParsing_stopList;
MPRINT(TMWRITEMULTI):   select count(*) into :startds_count from EMWS1.TextParsing_startList;
MPRINT(TMWRITEMULTI):   select count(*) into :multids_count from EMWS1.TextParsing_multiDS;
MPRINT(TMWRITEMULTI):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(TMWRITEMULTI):   * check the synonym ds for multiword terms ;
MPRINT(FIND_MULTIWORD_TERMS):   data work.internal_synds_temp (keep=term role);
MPRINT(FIND_MULTIWORD_TERMS):   length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
MPRINT(FIND_MULTIWORD_TERMS):   set work.internal_synds;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
MPRINT(FIND_MULTIWORD_TERMS):   if childrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if lowcase(category) eq category then category=propcase(category) ;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if "work.internal_synds"="work.internal_synds" and anypunct(term,1) > 0 then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = parent;
MPRINT(FIND_MULTIWORD_TERMS):   if parentrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Variable child is uninitialized.
NOTE: Variable childrole is uninitialized.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set WORK.INTERNAL_SYNDS_TEMP has 1 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.17 seconds
      cpu time            0.03 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc append base=_multiterms_ data=work.internal_synds_temp force;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Appending WORK.INTERNAL_SYNDS_TEMP to WORK._MULTITERMS_.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS_TEMP.
NOTE: 1 observations added.
NOTE: The data set WORK._MULTITERMS_ has 1 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc sql noprint;
MPRINT(FIND_MULTIWORD_TERMS):   drop table work.internal_synds_temp;
NOTE: Table WORK.INTERNAL_SYNDS_TEMP has been dropped.
MPRINT(FIND_MULTIWORD_TERMS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):  ;
MPRINT(TMWRITEMULTI):   * check the stopTerms ds for multiword terms ;
MPRINT(FIND_MULTIWORD_TERMS):   data EMWS1.TextParsing_stopList_temp (keep=term role);
MPRINT(FIND_MULTIWORD_TERMS):   length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
MPRINT(FIND_MULTIWORD_TERMS):   set EMWS1.TextParsing_stopList;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
MPRINT(FIND_MULTIWORD_TERMS):   if childrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if lowcase(category) eq category then category=propcase(category) ;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if "EMWS1.TextParsing_stopList"="work.internal_synds" and anypunct(term,1) > 0 then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = parent;
MPRINT(FIND_MULTIWORD_TERMS):   if parentrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Variable child is uninitialized.
NOTE: Variable childrole is uninitialized.
NOTE: Variable parent is uninitialized.
NOTE: Variable parentrole is uninitialized.
NOTE: There were 507 observations read from the data set EMWS1.TEXTPARSING_STOPLIST.
NOTE: The data set EMWS1.TEXTPARSING_STOPLIST_TEMP has 0 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc append base=_multiterms_ data=EMWS1.TextParsing_stopList_temp force;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Appending EMWS1.TEXTPARSING_STOPLIST_TEMP to WORK._MULTITERMS_.
NOTE: There were 0 observations read from the data set EMWS1.TEXTPARSING_STOPLIST_TEMP.
NOTE: 0 observations added.
NOTE: The data set WORK._MULTITERMS_ has 1 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc sql noprint;
MPRINT(FIND_MULTIWORD_TERMS):   drop table EMWS1.TextParsing_stopList_temp;
NOTE: Table EMWS1.TEXTPARSING_STOPLIST_TEMP has been dropped.
MPRINT(FIND_MULTIWORD_TERMS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):  ;
MPRINT(TMWRITEMULTI):   * check the startTerms ds for multiword terms;
MPRINT(TMWRITEMULTI):   * check the multids for multiword terms ;
MPRINT(TMWRITEMULTI):   data work.multids_temp;
MPRINT(TMWRITEMULTI):   length term $256 role $256;
MPRINT(TMWRITEMULTI):   set EMWS1.TextParsing_multiDS;
MPRINT(TMWRITEMULTI):   if role eq '' then role='Noun';
MPRINT(TMWRITEMULTI):   run;

NOTE: There were 384 observations read from the data set EMWS1.TEXTPARSING_MULTIDS.
NOTE: The data set WORK.MULTIDS_TEMP has 384 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TMWRITEMULTI):   proc append base=_multiterms_ data=work.multids_temp(keep=term role) force;
MPRINT(TMWRITEMULTI):   run;

NOTE: Appending WORK.MULTIDS_TEMP to WORK._MULTITERMS_.
NOTE: There were 384 observations read from the data set WORK.MULTIDS_TEMP.
NOTE: 384 observations added.
NOTE: The data set WORK._MULTITERMS_ has 385 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   drop table work.multids_temp;
NOTE: Table WORK.MULTIDS_TEMP has been dropped.
NOTE: PROC SQL statements are executed immediately; The RUN statement has no effect.
MPRINT(TMWRITEMULTI):   run;
MPRINT(TMWRITEMULTI):   * add lower and upper case variations to the multi word terms ;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   data _multiterms_;
MPRINT(TMWRITEMULTI):   set _multiterms_;
MPRINT(TMWRITEMULTI):   term = transtrn(term, ':', '\:');
MPRINT(TMWRITEMULTI):   * output exactly as is ;
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output lower case versions ;
MPRINT(TMWRITEMULTI):   term=lowcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output upper case versions ;
MPRINT(TMWRITEMULTI):   term=upcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output uppercase first letter of each term, lower rest ;
MPRINT(TMWRITEMULTI):   term = propcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   run;

NOTE: There were 385 observations read from the data set WORK._MULTITERMS_.
NOTE: The data set WORK._MULTITERMS_ has 1540 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.04 seconds
      

MPRINT(TMWRITEMULTI):   * remove duplicate term entries ;
MPRINT(TMWRITEMULTI):   proc sort data= _multiterms_ nodupkey;
MPRINT(TMWRITEMULTI):   by term role;
MPRINT(TMWRITEMULTI):   run;

NOTE: There were 1540 observations read from the data set WORK._MULTITERMS_.
NOTE: 385 observations with duplicate key values were deleted.
NOTE: The data set WORK._MULTITERMS_ has 1155 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(TMWRITEMULTI):   filename _multout "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\multiword.txt";
MPRINT(TMWRITEMULTI):   * write out all the multiword terms ;
MPRINT(TMWRITEMULTI):   data EMWS1.TextParsing_multiall;
MPRINT(TMWRITEMULTI):   set _multiterms_;
MPRINT(TMWRITEMULTI):   file _multout encoding="utf-8";
MPRINT(TMWRITEMULTI):   put term ':3:' role;
MPRINT(TMWRITEMULTI):   run;

NOTE: The file _MULTOUT is:
      Filename=C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\multiword.txt,
      RECFM=V,LRECL=131068,File Size (bytes)=0,
      Last Modified=27Apr2017:12:33:55,
      Create Time=23Apr2017:17:37:39

NOTE: 1155 records were written to the file _MULTOUT.
      The minimum record length was 10.
      The maximum record length was 29.
NOTE: There were 1155 observations read from the data set WORK._MULTITERMS_.
NOTE: The data set EMWS1.TEXTPARSING_MULTIALL has 1155 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   drop table EMWS1.TextParsing_tmconfig;
NOTE: Table EMWS1.TEXTPARSING_TMCONFIG has been dropped.
MPRINT(TM_PARSE):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_PARSE):   data _null_;
MPRINT(TM_PARSE):   posignore = "'AUX' 'CONJ' 'DET' 'INTERJ' 'PART' 'PREP' 'PRON'";
MPRINT(TM_PARSE):   posignore = transtrn(posignore, "'", '"');
MPRINT(TM_PARSE):   call symput("posignore", posignore);
MPRINT(TM_PARSE):   attribignore = "'NUM' 'PUNCT'";
MPRINT(TM_PARSE):   attribignore = transtrn(attribignore, "'", '"');
MPRINT(TM_PARSE):   call symput("attribignore", attribignore);
MPRINT(TM_PARSE):   run;

NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   select count(*) into :stoplist_count from EMWS1.TextParsing_stopList;
MPRINT(TM_PARSE):   select count(*) into :startlist_count from EMWS1.TextParsing_startList;
MPRINT(TM_PARSE):   select count(*) into :synds_count from work.internal_synds;
MPRINT(TM_PARSE):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_PARSE):   proc hptmine data=EMWS1.TextParsing_TRAIN language=english;
MPRINT(TM_PARSE):   var AdjusterNotes ;
MPRINT(TM_PARSE):   doc_id _document_;
MPRINT(TM_PARSE):   parse reducef=1 outterms=EMWS1.TextParsing_terms showdroppedterms stop=EMWS1.TextParsing_stopList syn=work.internal_synds entities=none multiterm="C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance 
Claim\Workspaces\EMWS1\TextParsing\multiword.txt" buildindex indexpath="C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\" outchild=EMWS1.TextParsing_tmout outpos=EMWS1.TextParsing_tmoutpos 
outconfig=EMWS1.TextParsing_tmconfig ;
MPRINT(TM_PARSE):   select "AUX" "CONJ" "DET" "INTERJ" "PART" "PREP" "PRON" "Newline" / ignore ;
MPRINT(TM_PARSE):   select "NUM" "PUNCT" / group="attributes" ignore;
MPRINT(TM_PARSE):   ;
MPRINT(TM_PARSE):   performance details;
MPRINT(TM_PARSE):   run;

NOTE: No SPARSEFORMAT option is specified. SPARSEFORMAT=COO will be run by default.
NOTE: Stemming will be used in parsing.
NOTE: Tagging will be used in parsing.
NOTE: Noun groups will be used in parsing.
NOTE: No TERMWGT option is specified. TERMWGT=ENTROPY will be run by default.
NOTE: No CELLWGT option is specified. CELLWGT=LOG will be run by default.
NOTE: The HPTMINE procedure is executing in single-machine mode.
NOTE: There were 302 observations read from the data set EMWS1.TEXTPARSING_TRAIN.
NOTE: There were 507 observations read from the data set EMWS1.TEXTPARSING_STOPLIST.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set EMWS1.TEXTPARSING_TERMS has 1579 observations and 11 variables.
NOTE: The data set EMWS1.TEXTPARSING_TMOUT has 2838 observations and 3 variables.
NOTE: The data set EMWS1.TEXTPARSING_TMOUTPOS has 2936 observations and 8 variables.
NOTE: The data set EMWS1.TEXTPARSING_TMCONFIG has 1 observations and 18 variables.
NOTE: The PROCEDURE HPTMINE printed page 8.
NOTE: PROCEDURE HPTMINE used (Total process time):
      real time           6.30 seconds
      cpu time            3.89 seconds
      

MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   create table EMWS1.TextParsing_terms as select *,_keep as keep from EMWS1.TextParsing_terms order by _keep desc,numdocs desc;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS1.TEXTPARSING_TERMS created, with 1579 rows and 12 columns.

MPRINT(TM_PARSE):   create table tempKey as select a.key as _termnum_, a.term, a.role from EMWS1.TextParsing_terms a where a._ispar ne '+';
NOTE: Table WORK.TEMPKEY created, with 1269 rows and 3 columns.

MPRINT(TM_PARSE):   create table tempoutpos as select a.document as _document_, a.sentence as _sentence_, a._start_ as _offset_, a._end_ - a._start_+1 as _length_, b._termnum_ from EMWS1.TextParsing_tmoutpos as a , tempKey as b where b.term=a.term and 
b.role=a.role;
NOTE: Table WORK.TEMPOUTPOS created, with 2936 rows and 5 columns.

MPRINT(TM_PARSE):   create table tempoutds as select a.* from EMWS1.TextParsing_tmout as a, tempkey as b where a._termnum_= b._termnum_;
NOTE: Table WORK.TEMPOUTDS created, with 2838 rows and 3 columns.

MPRINT(TM_PARSE):   create table EMWS1.TextParsing_tmoutpos as select a._document_, a._sentence_, a._offset_, a. _length_, a._termnum_, b._count_ from tempoutpos as a, tempoutds as b where a._termnum_=b._termnum_ and a._document_ =b._document_;
NOTE: Table EMWS1.TEXTPARSING_TMOUTPOS created, with 2936 rows and 6 columns.

MPRINT(TM_PARSE):   drop table tempoutpos;
NOTE: Table WORK.TEMPOUTPOS has been dropped.
MPRINT(TM_PARSE):   drop table tempKey;
NOTE: Table WORK.TEMPKEY has been dropped.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.21 seconds
      cpu time            0.09 seconds
      

MPRINT(TM_PARSE):   proc sort data=EMWS1.TextParsing_tmout;
MPRINT(TM_PARSE):   by _termnum_ _document_;
MPRINT(TM_PARSE):   run;

NOTE: There were 2838 observations read from the data set EMWS1.TEXTPARSING_TMOUT.
NOTE: The data set EMWS1.TEXTPARSING_TMOUT has 2838 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_PARSE):   quit;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc sql;
MPRINT(TRAIN):   create table EMWS1.TextParsing_terms as select a.key label= "Key", a.term label= "Term", a.role, case a.role when 'Abbr' then "Abbr" when 'Adj' then "Adj" when 'Adv' then "Adv" when 'Aux' then "Aux" when 'Conj' then "Conj" when 'Det' then 
"Det" when 'Interj' then "Interj" when 'Noun' then "Noun" when 'Num' then "Num" when 'Part' then "Part" when 'Pref' then "Pref" when 'Prep' then "Prep" when 'Pron' then "Pron" when 'Prop' then "Prop" when 'Punct' then "Punct" when 'Verb' then "Verb" when 
'VerbAdj' then "VerbAdj" when 'PERSON' then "Person" when 'ORGANIZATION' then "Organization" when 'LOCATION' then "Location" when 'COMPANY' then "Company" when 'TITLE' then "Title" when 'PHONE' then "Phone Number" when 'DATE' then "Date" when 'TIME' then 
"Time" when 'INTERNET' then "Internet" when 'MEASURE' then "Measure" when 'NOUN_GROUP' then "Noun Group" when 'SSN' then "Social Security Number" when 'CURRENCY' then "Currency" when 'PERCENT' then "Percent" when 'TIME_PERIOD' then "Time Period" when 
'PROP_MISC' then "Miscellaneous Proper Noun" when 'VEHICLE' then "Vehicle" when 'ADDRESS' then "Address" else a.role end as rolestring label="Role", a.attribute, case a.attribute when 'Alpha' then "Alpha" when 'Mixed' then "Mixed" when 'Num' then "Num" 
when 'Entity' then "Entity" else a.ATTRIBUTE end as attrstring label="Attribute", a.freq label="Freq", a.numdocs label="# Docs", a.keep label="Keep", a._ispar label="Parent/Child Status", a.parent label="Parent", a.parent_id label="Parent ID" from 
EMWS1.TextParsing_terms a;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS1.TEXTPARSING_TERMS created, with 1579 rows and 12 columns.

MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.21 seconds
      cpu time            0.18 seconds
      

MPRINT(TRAIN):   data EMWS1.TextParsing_tmconfig;
MPRINT(TRAIN):   length multiencoding $24 NG $3 ;
MPRINT(TRAIN):   set EMWS1.TextParsing_tmconfig;
MPRINT(TRAIN):   parseVar = lowcase("AdjusterNotes                   ");
MPRINT(TRAIN):   displayVar = lowcase("");
MPRINT(TRAIN):   indexpath = "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\";
MPRINT(TRAIN):   multiencoding="utf-8";
MPRINT(TRAIN):   filterLangs="";
MPRINT(TRAIN):   if NG="Y" then NG="STD";
MPRINT(TRAIN):   else if NG="N" then NG="OFF";
MPRINT(TRAIN):   if entities="STD" then entities="Y";
MPRINT(TRAIN):   language=lowcase(language);
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS1.TEXTPARSING_TMCONFIG.
NOTE: The data set EMWS1.TEXTPARSING_TMCONFIG has 1 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS1.TextParsing_terms;
MPRINT(TRAIN):   by term role;
MPRINT(TRAIN):   run;

NOTE: There were 1579 observations read from the data set EMWS1.TEXTPARSING_TERMS.
NOTE: The data set EMWS1.TEXTPARSING_TERMS has 1579 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data EMWS1.TextParsing_EMINFO;
MPRINT(TRAIN):   length TARGET KEY $32 DATA $43;
MPRINT(TRAIN):   key="LastTMNode";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTMNodeType";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTextParsing";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   run;

NOTE: Variable TARGET is uninitialized.
NOTE: The data set EMWS1.TEXTPARSING_EMINFO has 3 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: TextParsing;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35640      *------------------------------------------------------------*;
35641      * End TRAIN: TextParsing;
35642      *------------------------------------------------------------*;
35643      
35644      
35645      
35646      

35647      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
35648      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
35649      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35650      ;
MPRINT(EM_DIAGRAM):   ;
35651      ;
MPRINT(EM_DIAGRAM):   ;
35652      ;
MPRINT(EM_DIAGRAM):   ;
35653      ;
MPRINT(EM_DIAGRAM):   ;
35654      quit;
MPRINT(EM_DIAGRAM):   quit;
35655      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35656      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
35657      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35658      /*; *"; *'; */
35659      ;
MPRINT(EM_DIAGRAM):   ;
35660      run;
MPRINT(EM_DIAGRAM):   run;
35661      quit;
MPRINT(EM_DIAGRAM):   quit;
35662      /* Reset EM Options */
35663      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
35664      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
35665      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
35666      proc sort data=WORK.EM_METACHANGE;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_METACHANGE;
35667      by key uname;
MPRINT(EM_DIAGRAM):   by key uname;
35668      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 1 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 1 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

35669      filename x "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\CDELTA_TRAIN.sas";
MPRINT(EM_DIAGRAM):    filename x "C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\CDELTA_TRAIN.sas";
35670      data _null_;
MPRINT(EM_DIAGRAM):   data _null_;
35671      file x;
MPRINT(EM_DIAGRAM):   file x;
35672      put 'if upcase(NAME) = "_DOCUMENT_" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "_DOCUMENT_" then do;';
35673      put 'ROLE = "ID";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "ID";';
35674      put 'LEVEL = "NOMINAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "NOMINAL";';
35675      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35676      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: The file X is:
      Filename=C:\Users\Gaurav\Desktop\second sem\Data Mining\Project 3\Insurance Claim\Workspaces\EMWS1\TextParsing\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=27Apr2017:12:34:02,
      Create Time=23Apr2017:17:31:40

NOTE: 4 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 39.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

35677      filename x;
MPRINT(EM_DIAGRAM):   filename x;
NOTE: Fileref X has been deassigned.
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
